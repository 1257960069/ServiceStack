<script>
let OPS_CACHE = {}
function Api({ store }) {
    return {
        $template: `#api-form-template`,
        store,
        apiResult: null,
        requestDto: null,
        get request() { return this.store.op.request },
        get opName() { return this.request && this.request.name },
        get title() { return this.request && (this.request.description || humanify(this.request.name)) },
        resolveFormLayout,
        onAjaxForm(e) {
            let form = e.target
            let op = form.getAttribute('data-api')
            if (!op) {
                console.log('!op', form)
                return
            }
            let obj = formValues(e.target)
            apiSend(op, obj).then(r => {
                this.setOpResponse(op, r)
            })
        },
        onAjaxFormInput(e) {
            let form = e.target.tagName === 'FORM' ? e.target : e.target.form
            if (!(form && form.tagName === 'FORM')) return
            this.requestDto = createDto(form.getAttribute('data-api'), formValues(form))
        },
        onJsonSubmit(e) {
            let json = $1('textarea',e.target).value
            let obj = JSON.parse(json)
            apiSend(this.opName, obj).then(r => {
                this.setOpResponse(this.opName, r)
            })
        },

        setOpResponse(op, r) {
            this.apiResult = OPS_CACHE[op] = r
            this.requestDto = this.apiResult && this.apiResult.requestDto
        },

        get apiResultValid() {
            return this.apiResult && this.apiResult.opName === this.opName
        },
        
        get apiRequestJson() {
            return this.requestDto && JSON.stringify(this.requestDto, undefined, 4) || ''
        },
    }
}
Components.push({ Api })

function humanify(id) { return humanize(toPascalCase(id)) }

let useType = type => (acc,x) => { acc[x]=type; return acc }
let InputTypes = {
    bool: 'checkbox',
    ...'DateTime,DateTimeOffset,DateOnly'.split(',').reduce(useType('date'), {}),
    ...'TimeSpan,TimeOnly'.split(',').reduce(useType('time'), {}),
    ...'byte,short,int,long,ushort,uint,ulong,float,double,decimal'.split(',').reduce(useType('number'), {}),
    ...'string,Guid,Uri'.split(',').reduce(useType('text'), {}),
}

function resolveFormLayout(op) {
    let allProps = typeProperties(op.request).filter(supportsProp)
    if (op.formLayout) {
        let allPropsMap = allProps.reduce((acc,x) => { acc[x.name] = x; return acc }, {})
        let ret = op.formLayout.map(group => group.map(input => ({ ...inputProp(allPropsMap[input.id]), ...input }) ))
        return ret
    }
    let formLayout = []
    let inputProps = allProps.map(inputProp)
    let fullWidthTypes = ['textarea','divider']
    let fullWidth = input => input && (fullWidthTypes.indexOf(input.type) >= 0 || input['data-type'] === 'List`1')
    let pagingStart = inputProps.findIndex(x => x.id.toLowerCase() === 'skip')
    if (pagingStart >= 0) inputProps.splice(pagingStart, 0, {type:'divider'})
    while (inputProps.length > 0) {
        let left = inputProps.shift();
        let right = inputProps.length > 0 ? inputProps.shift() : null;
        if (fullWidth(left) || fullWidth(right)) {
            formLayout.push([left])
            if (right) formLayout.push([right])
        } else {
            formLayout.push(right ? [left,right] : [left])
        }
    }
    return formLayout
}

function formValues(form) {
    let obj = {}
    Array.from(form.elements).forEach(el => {
        if (!el.id || el.value == null || el.value === '') return
        let dataType = el.getAttribute('data-type')
        let dataArgs = (el.getAttribute('data-args') || '').split(','), dataArg = dataArgs[0]
        let value = el.type === 'checkbox'
            ? el.checked
            : el.value
        if (isNumberType(dataType) || (dataType === 'Nullable`1' && isNumberType(dataArg))) {
            value = Number(value)
        } else if (dataType === 'List`1') {
            value = value.split(',').map(x => isNumberType(dataArg)
                ? Number(x)
                : x)
        }
        obj[el.id] = value
    })
    return obj
}

function createDto(name, obj) {
    let dtoCtor = window[name]
    if (!dtoCtor) {
        console.log(`Couldn't find Request DTO for ${name}`)
        let AnonResponse = /** @class */ (function () { return function (init) { Object.assign(this, init) } }())
        dtoCtor = /** @class */ (function () {
            function AnonRequest(init) { Object.assign(this, init) }
            AnonRequest.prototype.createResponse = function () { return new AnonResponse() }
            AnonRequest.prototype.getTypeName = function () { return name }
            AnonRequest.prototype.getMethod = function () { return 'POST' }
            return AnonRequest
        }())
    }
    return new dtoCtor(obj)
}

function parseCookie(str) {
    return str.split(';').map(v => v.split('=')) .reduce((acc, v) => {
            acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());
            return acc;
        }, {});
}

function apiSend(opName, obj) {
    let requestDto = createDto(opName, obj)
    let httpReq = null, httpRes = null, headers = null
    let cookies = parseCookie(document.cookie)
    let newClient = createClient(c => {
        c.requestFilter = req => httpReq = req
        c.responseFilter = res => {
            httpRes = res
            headers = Object.fromEntries(res.headers)
        }
    })
    let returnsVoid = typeof requestDto.createResponse == 'function' && !requestDto.createResponse()
    let task = returnsVoid
        ? newClient.apiVoid(requestDto)
        : newClient.api(requestDto)
    return task.then(api => ({ 
        api,
        json: JSON.stringify(api.response || api.error, undefined, 4),
        text: JSON.stringify(api.response || api.error),
        opName,
        requestDto, 
        httpReq, 
        httpRes,
        headers,
        cookies,
    }))
}

function groupTypes(allTypes) {
    let allTypesMap = {}
    let groups = []
    allTypes.forEach(type => {
        if (allTypesMap[type.name]) return
        let group = []
        let addTypeDef = typeDef => {
            if (!typeDef || allTypesMap[typeDef.name]) return
            allTypesMap[typeDef.name] = typeDef
            group.push({ type: typeDef, typeName: typeName(typeDef) })
        }
        let addTypeRef = typeRef => {
            if (!typeRef || allTypesMap[typeRef.name]) return
            let typeDef = TypesMap[typeRef.name]
            allTypesMap[typeDef.name] = typeDef
            group.push({ type: typeDef, typeName: typeName(typeRef) })
            return typeDef
        }
        addTypeDef(type)
        if (type.inherits) {
            let subType = addTypeRef(type.inherits)
            while (subType) {
                subType = subType.inherits ? addTypeRef(subType.inherits) : null
            }
        }
        groups.push(group)
    })
    return groups
}

function inputProp(prop) {
    let id = toCamelCase(prop.name), idLower = id.toLowerCase()
    let propType = unwrap(typeName2(prop.type, prop.genericArgs))
    let input = { id, type:inputType(propType), 'data-type': prop.type }
    if (prop.genericArgs) input['data-args'] = prop.genericArgs.join(',')
    let type = TypesMap[propType]
    if (type && type.isEnum) {
        input.type = 'select'
        if (type.enumValues) {
            input.allowableEntries = []
            for (let i=0; i<type.enumNames; i++) {
                input.allowableEntries.push({ key:type.enumValues[i], value:type.enumNames[i] })
            }
        } else {
            input.allowableValues = type.enumNames
        }
    } else if (idLower.indexOf('password') >= 0) {
        input.type = 'password'
    } else if (idLower === 'email') {
        input.type = 'email'
    } else if (idLower.endsWith('url')) {
        input.type = 'url'
    }
    if (prop.input)
        Object.assign(input, prop.input)
    return input
}
function inputType(typeName) {
    if (!typeName) return null
    typeName = unwrap(typeAlias(typeName))
    return InputTypes[typeName]
}
function supportsProp(prop) {
    let propType = typeName2(prop.type, prop.genericArgs)
    if (prop.isValueType || prop.isEnum || inputType(propType))
        return true
    if (prop.type === 'List`1' && inputType(prop.genericArgs[0]))
        return true
    console.log('!supportsProp', 'propType', propType, prop.type, prop.genericArgs, inputType(prop.genericArgs[0]))
    return false
}

</script>
<template id="api-form-template">
<nav class="flex space-x-4 pl-2 pt-2.5 pb-1.5 border-b bg-white" aria-label="Tabs">
    <a v-for="formTab in ['form','json']" @click.prevent="store.formTab=formTab"
       :class="[store.formTab==formTab ? 'bg-gray-100 text-gray-700' : 'uppercase text-gray-500 hover:text-gray-700', 'cursor-pointer px-3 py-1 font-medium text-sm rounded-md']">
        {{formTab.toUpperCase()}}
    </a>
</nav>

<div v-if="store.formTab=='form'" class="p-4 max-w-screen-md"
     v-scope="AutoForm({ 
        title:() => title, 
        layout: () => resolveFormLayout(store.op), 
        api: () => opName,
        error: () => apiResult && apiResult.api.error,  
        onsubmit:onAjaxForm.bind(store),
        oninput:onAjaxFormInput.bind(store)
    })"></div>
<div v-if="store.formTab=='json'">

<form @submit.prevent="onJsonSubmit" autocomplete="off" :data-api="opName" class="p-4">
    <div class="shadow overflow-hidden sm:rounded-md bg-white">
        <div class="relative px-4 py-5 bg-white sm:p-6">
            <fieldset>
                <legend class="text-lg text-gray-900 text-center mb-4">{{ title }}</legend>
                <div class="flex">
                    <textarea class="flex-1" :rows="apiRequestJson.split('\n').length" v-html="apiRequestJson"></textarea>
                </div>
            </fieldset>
        </div>
        <div class="mt-4 px-4 py-3 bg-gray-50 text-right sm:px-6">
            <div class="flex justify-end">
                <button type="submit" class="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">Submit</button>
            </div>
        </div>
    </div>
</form>
    
</div>

<div v-if="apiResultValid" v-scope="ApiResponse({ store, apiResult })"></div>
</template>

<script>
function ApiResponse({ store, apiResult }) {
    return {
        $template: '#api-response-template',
        store,
        apiResult,
        toKvps(obj) {
            return Object.keys(obj).map(k => ({ Key:k, Value:obj[k]}))
        },
        get tabs() {
          let tabs = { Body:'' }
            tabs[this.headersLabel] = 'headers'
            tabs[this.cookiesLabel] = 'cookies'
            return tabs
        },
        get headersLabel() {
            let count = apiResult && Object.keys(apiResult.headers).length || 0
            return `Headers (${count})`
        },
        get cookiesLabel() {
            let count = apiResult && Object.keys(apiResult.cookies).length || 0
            return `Cookies (${count})`
        },
        fieldAttrs(id) {
            let useId = id.replace(/\s+/g,'').toLowerCase() 
            return useId === 'stacktrace' 
                ? { 'class': 'whitespace-pre overflow-x-auto' } 
                : {}
        }
    }
}
Components.push({ ApiResponse })
</script>
<template id="api-response-template">
<div class="mt-2 border-t">
    <div class="border-b border-gray-200">
        <nav class="-mb-px flex space-x-4 pl-2" aria-label="Tabs">
            <a v-for="(tab,name) in tabs" :href="store.createHref({ response:tab })" @click.prevent="store.select({ response:tab })" 
               :class="[store.response == tab ? 'border-indigo-500 text-indigo-600' : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300', 'whitespace-nowrap py-1 px-1 border-b-2 font-medium text-sm']">
                {{name}}
            </a>
        </nav>
    </div>

    <div v-if="store.response == ''" class="p-2">
        <span class="relative z-0 inline-flex shadow-sm rounded-md">
          <a v-for="(tab,name) in {Pretty:'',Raw:'raw',Preview:'preview'}" :href="store.createHref({ body:tab })" @click.prevent="store.select({ body:tab })"
              :class="[{ Pretty:'rounded-l-md',Raw:'-ml-px',Preview:'rounded-r-md -ml-px' }[name], store.body == tab ? 'z-10 outline-none ring-1 ring-indigo-500 border-indigo-500' : '', 'cursor-pointer relative inline-flex items-center px-4 py-1 border border-gray-300 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50']">
            {{name}}
          </a>
        </span>

        <div v-if="store.body == ''" class="pt-2 copy-outer">
            <div v-if="apiResult.json" v-scope="Copy({ text:() => apiResult.json })"></div>
            <pre class="whitespace-pre-wrap"><code lang="json" v-highlightjs="apiResult.json"></code></pre>
        </div>
        <div v-else-if="store.body == 'raw'" class="flex pt-2">
            <textarea class="flex-1" rows="10" v-html="apiResult.text"></textarea>
        </div>
        <div v-else-if="store.body == 'preview'" class="body-preview flex pt-2 overflow-x-auto">
            <div class="" v-scope="PreviewObject({ val:apiResult.api.response || apiResult.api.error, fieldAttrs })"></div>
        </div>
    </div>
    <div v-else-if="store.response == 'cookies'" class="p-4">
        <div v-if="apiResult.cookies" v-scope="ArrayPreview({ val:toKvps(apiResult.cookies) })"></div>
        <div class="mt-4" v-scope="Alert({ message:'HttpOnly Cookies are not displayed' })"></div>
    </div>
    <div v-else-if="store.response == 'headers'" class="p-4">
        <div v-if="apiResult.headers" v-scope="ArrayPreview({ val:toKvps(apiResult.headers) })"></div>
    </div>
</div>
</template>
